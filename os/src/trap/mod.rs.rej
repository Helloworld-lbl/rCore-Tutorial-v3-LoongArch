diff a/os/src/trap/mod.rs b/os/src/trap/mod.rs	(rejected hunks)
@@ -1,32 +1,26 @@
-//! Trap handling functionality
-//!
-//! For rCore, we have a single trap entry point, namely `__alltraps`. At
-//! initialization in [`init()`], we set the `stvec` CSR to point to it.
-//!
-//! All traps go through `__alltraps`, which is defined in `trap.S`. The
-//! assembly language code does just enough work restore the kernel space
-//! context, ensuring that Rust code safely runs, and transfers control to
-//! [`trap_handler()`].
-//!
-//! It then calls different functionality based on what exactly the exception
-//! was. For example, timer interrupts trigger task preemption, and syscalls go
 //! to [`syscall()`].
 mod context;
 
-use crate::config::{TRAMPOLINE, TRAP_CONTEXT};
+use crate::config::TRAMPOLINE;
 use crate::syscall::syscall;
 use crate::task::{
-    current_trap_cx, current_user_token, exit_current_and_run_next, suspend_current_and_run_next,
+    current_user_token, exit_current_and_run_next, suspend_current_and_run_next
 };
-use crate::timer::set_next_trigger;
 use core::arch::{asm, global_asm};
-use riscv::register::{
-    mtvec::TrapMode,
-    scause::{self, Exception, Interrupt, Trap},
-    sie, stval, stvec,
-};
+use loongarch::register::{
+    eentry,
+    estat::{
+        self, 
+        Trap, 
+        Exception,
+        Interrupt},
+    ticlr::Ticlr,
+    badv,
+    };
 
+global_asm!(include_str!("tlbr.S"));
 global_asm!(include_str!("trap.S"));
+
 /// initialize CSR `stvec` as the entry of `__alltraps`
 pub fn init() {
     set_kernel_trap_entry();
@@ -34,72 +28,51 @@ pub fn init() {
 
 fn set_kernel_trap_entry() {
     unsafe {
-        stvec::write(trap_from_kernel as usize, TrapMode::Direct);
+        eentry::write(trap_from_kernel as usize >> 12);
     }
 }
 
 fn set_user_trap_entry() {
     unsafe {
-        stvec::write(TRAMPOLINE as usize, TrapMode::Direct);
-    }
-}
-/// enable timer interrupt in sie CSR
-pub fn enable_timer_interrupt() {
-    unsafe {
-        sie::set_stimer();
+        eentry::write(TRAMPOLINE as usize >> 12);
     }
 }
 
 #[no_mangle]
 /// handle an interrupt, exception, or system call from user space
-pub fn trap_handler() -> ! {
+pub fn trap_handler(cx: &mut TrapContext) -> ! {
     set_kernel_trap_entry();
-    let scause = scause::read();
-    let stval = stval::read();
-    match scause.cause() {
-        Trap::Exception(Exception::UserEnvCall) => {
-            // jump to next instruction anyway
-            let mut cx = current_trap_cx();
-            cx.sepc += 4;
-            // get system call return value
-            let result = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]);
-            // cx is changed during sys_exec, so we have to call it again
-            cx = current_trap_cx();
-            cx.x[10] = result as usize;
+    let estat = estat::read(); // get trap cause
+    let badv = badv::read();
+    match estat.cause() {
+        Trap::Exception(Exception::SYS) => {
+            cx.era += 4;
+            cx.r[4] = syscall(cx.r[11], [cx.r[4], cx.r[5], cx.r[6]]) as usize;
         }
-        Trap::Exception(Exception::StoreFault)
-        | Trap::Exception(Exception::StorePageFault)
-        | Trap::Exception(Exception::InstructionFault)
-        | Trap::Exception(Exception::InstructionPageFault)
-        | Trap::Exception(Exception::LoadFault)
-        | Trap::Exception(Exception::LoadPageFault) => {
-            println!(
-                "[kernel] {:?} in application, bad addr = {:#x}, bad instruction = {:#x}, kernel killed it.",
-                scause.cause(),
-                stval,
-                current_trap_cx().sepc,
-            );
-            // page fault exit code
+        Trap::Exception(Exception::PIS) => {
+            println!("[kernel] Trap::Exception(Exception::PIS) Invalid store operation page exception in application, bad addr = {:#x}, kernel killed it.", badv.bits());
+            exit_current_and_run_next(-2);
+        }
+        Trap::Exception(Exception::PIL) => {
+            println!("[kernel] Trap::Exception(Exception::PIL) Invalid load operation page exception in application, bad addr = {:#x}, kernel killed it.", badv.bits());
             exit_current_and_run_next(-2);
         }
-        Trap::Exception(Exception::IllegalInstruction) => {
-            println!("[kernel] IllegalInstruction in application, kernel killed it.");
-            // illegal instruction exit code
+        Trap::Exception(Exception::IPE) => {
+            println!("[kernel] Trap::Exception(Exception::IPE) Instruction privilege level exception in application, kernel killed it.");
             exit_current_and_run_next(-3);
         }
-        Trap::Interrupt(Interrupt::SupervisorTimer) => {
-            set_next_trigger();
+        Trap::Interrupt(Interrupt::TI) => {
+            Ticlr::clear();
             suspend_current_and_run_next();
         }
         _ => {
             panic!(
-                "Unsupported trap {:?}, stval = {:#x}!",
-                scause.cause(),
-                stval
+                "Unsupported trap {:?}!",
+                estat.cause()
             );
         }
     }
-    //println!("before trap_return");
+    unsafe { asm!("or $sp, $fp, $r0"); }
     trap_return();
 }
 
@@ -109,8 +82,7 @@ pub fn trap_handler() -> ! {
 /// finally, jump to new addr of __restore asm function
 pub fn trap_return() -> ! {
     set_user_trap_entry();
-    let trap_cx_ptr = TRAP_CONTEXT;
-    let user_satp = current_user_token();
+    let user_pgdl = current_user_token();
     extern "C" {
         fn __alltraps();
         fn __restore();
@@ -132,9 +104,7 @@ pub fn trap_return() -> ! {
 /// Unimplement: traps/interrupts/exceptions from kernel mode
 /// Todo: Chapter 9: I/O device
 pub fn trap_from_kernel() -> ! {
-    use riscv::register::sepc;
-    println!("stval = {:#x}, sepc = {:#x}", stval::read(), sepc::read());
-    panic!("a trap {:?} from kernel!", scause::read().cause());
+    panic!("a trap {:?} from kernel!", estat::read().cause());
 }
 
 pub use context::TrapContext;
